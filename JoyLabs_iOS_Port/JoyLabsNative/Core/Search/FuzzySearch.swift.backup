import Foundation
import SwiftData
import os.log

/// Simple, effective fuzzy search using tokenized prefix matching
/// Matches word beginnings only - no middle/end word matching to eliminate noise
class FuzzySearch {
    
    private let logger = Logger(subsystem: "com.joylabs.native", category: "FuzzySearch")
    
    // MARK: - Scoring Constants
    private struct Scores {
        static let exactWordMatch: Double = 100.0
        static let prefixMatch: Double = 80.0
        static let exactSkuMatch: Double = 60.0
        static let prefixSkuMatch: Double = 40.0
        static let upcMatch: Double = 60.0
        static let multiTokenBonus: Double = 2.0  // Increased for better multi-token prioritization
        static let allTokensMatchBonus: Double = 50.0  // Big bonus for matching ALL tokens
    }
    
    private struct Config {
        static let maxResults: Int = 200
        static let minTokenLength: Int = 2
        static let minScoreThreshold: Double = 20.0
    }
    
    // MARK: - Main Search Function
    
    func performFuzzySearch(
        searchTerm: String,
        in database: Connection,
        filters: SearchFilters,
        limit: Int = 50
    ) throws -> [SearchResultWithScore] {
        
        let cleanTerm = searchTerm.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !cleanTerm.isEmpty else { return [] }
        
        // Starting fuzzy search
        
        // Determine search type based on content
        let isNumericQuery = cleanTerm.allSatisfy { $0.isNumber }
        
        let candidates: [CandidateItem]
        
        if isNumericQuery {
            // Numeric query: search UPC/barcode fields only
            candidates = try searchNumericFields(term: cleanTerm, database: database, filters: filters)
        } else {
            // Alphanumeric query: search name + SKU fields with tokenization
            candidates = try searchTextFields(term: cleanTerm, database: database, filters: filters)
        }
        
        // Found candidates
        
        // Score and rank candidates
        let scoredResults = scoreAndRankCandidates(
            candidates: candidates,
            searchTerm: cleanTerm,
            isNumeric: isNumericQuery
        )
        
        // Filter by minimum score and apply limit
        let filteredResults = scoredResults
            .filter { $0.score >= Config.minScoreThreshold }
            .prefix(limit)
        
        // Returning results after scoring
        return Array(filteredResults)
    }
    
    // MARK: - Numeric Search (UPC/Barcode)
    
    private func searchNumericFields(
        term: String,
        database: Connection,
        filters: SearchFilters
    ) throws -> [CandidateItem] {
        
        guard filters.barcode else { return [] }
        
        // Numeric search for UPC/barcode
        
        // Search UPC/barcode with exact and prefix matching
        let query = """
            SELECT DISTINCT 
                ci.id, ci.name, ci.category_id, ci.category_name, ci.reporting_category_name,
                iv.sku, iv.upc, iv.price_amount
            FROM catalog_items ci
            JOIN item_variations iv ON ci.id = iv.item_id
            WHERE ci.is_deleted = 0 AND iv.is_deleted = 0
            AND (iv.upc = ? OR iv.upc LIKE ?)
            ORDER BY 
                CASE 
                    WHEN iv.upc = ? THEN 1  -- Exact matches first
                    ELSE 2                  -- Prefix matches second
                END,
                ci.name ASC
            LIMIT \(Config.maxResults)
        """
        
        let prefixPattern = "\(term)%"
        let statement = try database.prepare(query)
        let results = try statement.run([term, prefixPattern, term])
        
        return results.compactMap { row in
            createCandidateFromVariationRow(row)
        }
    }
    
    // MARK: - Text Search (Name + SKU)
    
    private func searchTextFields(
        term: String,
        database: Connection,
        filters: SearchFilters
    ) throws -> [CandidateItem] {
        
        // Tokenize search term - split into individual words
        let tokens = tokenize(term)
        guard !tokens.isEmpty else { return [] }
        
        // Text search with tokens
        
        var candidates: [String: CandidateItem] = [:]
        
        // Search name field (if enabled)
        if filters.name {
            let nameResults = try searchNameField(tokens: tokens, database: database)
            mergeCandidates(&candidates, newCandidates: nameResults)
        }
        
        // Search SKU field (if enabled)  
        if filters.sku {
            let skuResults = try searchSkuField(tokens: tokens, database: database)
            mergeCandidates(&candidates, newCandidates: skuResults)
        }
        
        // TODO: Add case UPC search when implemented
        // This structure is ready but will return 0 results until backend support
        if filters.barcode {
            let caseUpcResults = try searchCaseUpcField(tokens: tokens, database: database)
            mergeCandidates(&candidates, newCandidates: caseUpcResults)
        }
        
        return Array(candidates.values)
    }
    
    private func searchNameField(tokens: [String], database: Connection) throws -> [CandidateItem] {
        // For multi-token searches, require ALL tokens to be found (AND logic)
        // For single token searches, use simple prefix matching
        
        if tokens.count == 1 {
            // Single token - simple prefix matching
            let token = tokens[0]
            let query = """
                SELECT DISTINCT 
                    ci.id, ci.name, ci.category_id, ci.category_name, ci.reporting_category_name
                FROM catalog_items ci
                WHERE ci.is_deleted = 0 
                AND (LOWER(ci.name) LIKE ? OR LOWER(ci.name) LIKE ?)
                ORDER BY ci.name ASC
                LIMIT \(Config.maxResults)
            """
            
            let statement = try database.prepare(query)
            let results = try statement.run(["\(token)%", "% \(token)%"])
            
            return results.compactMap { row in
                createCandidateFromItemRow(row)
            }
        } else {
            // Multi-token - require ALL tokens to be found (AND logic)
            var tokenConditions: [String] = []
            var bindValues: [Binding?] = []
            
            for token in tokens {
                // Each token must be found as word start somewhere in the name
                tokenConditions.append("(LOWER(ci.name) LIKE ? OR LOWER(ci.name) LIKE ?)")
                bindValues.append("\(token)%")  // Start of name
                bindValues.append("% \(token)%")  // Start of any word
            }
            
            let query = """
                SELECT DISTINCT 
                    ci.id, ci.name, ci.category_id, ci.category_name, ci.reporting_category_name
                FROM catalog_items ci
                WHERE ci.is_deleted = 0 
                AND \(tokenConditions.joined(separator: " AND "))
                ORDER BY ci.name ASC
                LIMIT \(Config.maxResults)
            """
            
            // Multi-token name query
            // Bind values prepared
            
            let statement = try database.prepare(query)
            let results = try statement.run(bindValues)
            
            return results.compactMap { row in
                createCandidateFromItemRow(row)
            }
        }
    }
    
    private func searchSkuField(tokens: [String], database: Connection) throws -> [CandidateItem] {
        // SKU field: require ALL tokens for multi-token searches
        if tokens.count == 1 {
            // Single token SKU search
            let token = tokens[0]
            let query = """
                SELECT DISTINCT 
                    ci.id, ci.name, ci.category_id, ci.category_name, ci.reporting_category_name,
                    iv.sku, iv.upc, iv.price_amount
                FROM catalog_items ci
                JOIN item_variations iv ON ci.id = iv.item_id
                WHERE ci.is_deleted = 0 AND iv.is_deleted = 0
                AND LOWER(iv.sku) LIKE ?
                ORDER BY ci.name ASC
                LIMIT \(Config.maxResults)
            """
            
            let statement = try database.prepare(query)
            let results = try statement.run(["\(token)%"])
            
            return results.compactMap { row in
                createCandidateFromVariationRow(row)
            }
        } else {
            // Multi-token SKU search - require ALL tokens
            var tokenConditions: [String] = []
            var bindValues: [Binding?] = []
            
            for token in tokens {
                tokenConditions.append("LOWER(iv.sku) LIKE ?")
                bindValues.append("%\(token)%")  // SKUs can have tokens anywhere
            }
            
            let query = """
                SELECT DISTINCT 
                    ci.id, ci.name, ci.category_id, ci.category_name, ci.reporting_category_name,
                    iv.sku, iv.upc, iv.price_amount
                FROM catalog_items ci
                JOIN item_variations iv ON ci.id = iv.item_id
                WHERE ci.is_deleted = 0 AND iv.is_deleted = 0
                AND \(tokenConditions.joined(separator: " AND "))
                ORDER BY ci.name ASC
                LIMIT \(Config.maxResults)
            """
            
            let statement = try database.prepare(query)
            let results = try statement.run(bindValues)
            
            return results.compactMap { row in
                createCandidateFromVariationRow(row)
            }
        }
    }
    
    private func searchCaseUpcField(tokens: [String], database: Connection) throws -> [CandidateItem] {
        // TODO: Implement case UPC search when backend support is added
        // For now, return empty results
        // Case UPC search not implemented
        return []
    }
    
    // MARK: - Tokenization
    
    private func tokenize(_ text: String) -> [String] {
        return text
            .lowercased()
            .components(separatedBy: CharacterSet.whitespacesAndNewlines.union(.punctuationCharacters))
            .filter { $0.count >= Config.minTokenLength }
            .map { $0.trimmingCharacters(in: .whitespacesAndNewlines) }
            .filter { !$0.isEmpty }
    }
    
    // MARK: - Candidate Management
    
    private func mergeCandidates(_ existing: inout [String: CandidateItem], newCandidates: [CandidateItem]) {
        for candidate in newCandidates {
            if let existingCandidate = existing[candidate.id] {
                // Merge data, keeping the most complete information
                existing[candidate.id] = CandidateItem(
                    id: candidate.id,
                    name: candidate.name,
                    sku: candidate.sku ?? existingCandidate.sku,
                    barcode: candidate.barcode ?? existingCandidate.barcode,
                    categoryName: candidate.categoryName ?? existingCandidate.categoryName,
                    categoryId: candidate.categoryId ?? existingCandidate.categoryId,
                    price: candidate.price ?? existingCandidate.price,
                    images: candidate.images ?? existingCandidate.images,
                    hasTax: candidate.hasTax
                )
            } else {
                existing[candidate.id] = candidate
            }
        }
    }
    
    // MARK: - Scoring and Ranking
    
    private func scoreAndRankCandidates(
        candidates: [CandidateItem],
        searchTerm: String,
        isNumeric: Bool
    ) -> [SearchResultWithScore] {
        
        // Scoring candidates
        
        let tokens = isNumeric ? [searchTerm] : tokenize(searchTerm)
        
        let scoredResults = candidates.compactMap { candidate -> SearchResultWithScore? in
            let score = calculateScore(candidate: candidate, searchTerm: searchTerm, tokens: tokens, isNumeric: isNumeric)
            guard score > 0 else { return nil }
            
            return SearchResultWithScore(
                item: convertToSearchResult(candidate, searchTerm: searchTerm, isNumeric: isNumeric),
                score: score,
                explanation: "Score: \(String(format: "%.1f", score))"
            )
        }
        
        let sortedResults = scoredResults.sorted { $0.score > $1.score }
        
        // Top results processed
        
        return sortedResults
    }
    
    private func calculateScore(
        candidate: CandidateItem,
        searchTerm: String,
        tokens: [String],
        isNumeric: Bool
    ) -> Double {
        
        if isNumeric {
            // Numeric search: score UPC matches
            return scoreUpcMatch(candidate: candidate, searchTerm: searchTerm)
        } else {
            // Text search: score name and SKU matches
            return scoreTextMatch(candidate: candidate, tokens: tokens)
        }
    }
    
    private func scoreUpcMatch(candidate: CandidateItem, searchTerm: String) -> Double {
        guard let upc = candidate.barcode else { return 0.0 }
        
        if upc == searchTerm {
            return Scores.upcMatch  // Exact UPC match
        } else if upc.hasPrefix(searchTerm) {
            // Prefix match - score based on how much of the UPC is matched
            let matchRatio = Double(searchTerm.count) / Double(upc.count)
            return Scores.upcMatch * (0.7 + 0.3 * matchRatio)
        }
        
        return 0.0
    }
    
    private func scoreTextMatch(candidate: CandidateItem, tokens: [String]) -> Double {
        var bestScore: Double = 0.0
        
        // Score name field
        if let name = candidate.name {
            let nameScore = scoreTextField(text: name, tokens: tokens, baseScore: Scores.exactWordMatch)
            bestScore = max(bestScore, nameScore)
        }
        
        // Score SKU field
        if let sku = candidate.sku {
            let skuScore = scoreTextField(text: sku, tokens: tokens, baseScore: Scores.exactSkuMatch)
            bestScore = max(bestScore, skuScore)
        }
        
        // Apply multi-token bonuses
        if tokens.count > 1 {
            let matchedTokens = countMatchedTokens(candidate: candidate, tokens: tokens)
            
            // Item token matching
            
            if matchedTokens == tokens.count {
                // ALL tokens matched - huge bonus
                bestScore += Scores.allTokensMatchBonus
                // All tokens matched bonus
            } else if matchedTokens > 1 {
                // Some tokens matched - proportional bonus
                let coverage = Double(matchedTokens) / Double(tokens.count)
                let bonus = coverage * (Scores.multiTokenBonus - 1.0)
                bestScore *= (1.0 + bonus)
                // Tokens matched coverage bonus
            }
        }
        
        return bestScore
    }
    
    private func scoreTextField(text: String, tokens: [String], baseScore: Double) -> Double {
        let words = text.lowercased().components(separatedBy: CharacterSet.alphanumerics.inverted).filter { !$0.isEmpty }
        var bestScore: Double = 0.0
        
        for token in tokens {
            for (wordIndex, word) in words.enumerated() {
                var wordScore: Double = 0.0
                
                if word == token {
                    // Exact word match
                    wordScore = baseScore
                } else if word.hasPrefix(token) {
                    // Prefix match - score based on how much of the word is matched
                    let matchRatio = Double(token.count) / Double(word.count)
                    wordScore = baseScore * 0.8 * (0.6 + 0.4 * matchRatio)
                }
                
                // Apply position bonus - earlier words are more important
                let positionMultiplier = max(0.5, 1.0 - Double(wordIndex) * 0.15)
                wordScore *= positionMultiplier
                
                bestScore = max(bestScore, wordScore)
            }
        }
        
        return bestScore
    }
    
    private func countMatchedTokens(candidate: CandidateItem, tokens: [String]) -> Int {
        var matchedCount = 0
        
        let nameWords = candidate.name?.lowercased().components(separatedBy: CharacterSet.alphanumerics.inverted).filter { !$0.isEmpty } ?? []
        let skuWords = candidate.sku?.lowercased().components(separatedBy: CharacterSet.alphanumerics.inverted).filter { !$0.isEmpty } ?? []
        let allWords = nameWords + skuWords
        
        for token in tokens {
            let hasMatch = allWords.contains { word in
                word == token || word.hasPrefix(token)
            }
            if hasMatch {
                matchedCount += 1
            }
        }
        
        return matchedCount
    }
    
    // MARK: - Helper Methods
    
    private func createCandidateFromItemRow(_ row: Statement.Element) -> CandidateItem? {
        guard let id = row[0] as? String,
              let name = row[1] as? String else { return nil }
        
        let categoryId = row[2] as? String
        let categoryName = row[3] as? String
        let reportingCategoryName = row[4] as? String
        
        return CandidateItem(
            id: id,
            name: name,
            sku: nil,
            barcode: nil,
            categoryName: reportingCategoryName ?? categoryName,
            categoryId: categoryId,
            price: nil,
            images: nil,
            hasTax: false
        )
    }
    
    private func createCandidateFromVariationRow(_ row: Statement.Element) -> CandidateItem? {
        guard let id = row[0] as? String,
              let name = row[1] as? String else { return nil }
        
        let categoryId = row[2] as? String
        let categoryName = row[3] as? String
        let reportingCategoryName = row[4] as? String
        let sku = row[5] as? String
        let upc = row[6] as? String
        let priceAmount = row[7] as? Int64
        
        let price: Double? = {
            guard let amount = priceAmount, amount > 0 else { return nil }
            let convertedPrice = Double(amount) / 100.0
            return convertedPrice.isFinite && !convertedPrice.isNaN && convertedPrice > 0 ? convertedPrice : nil
        }()
        
        return CandidateItem(
            id: id,
            name: name,
            sku: sku,
            barcode: upc,
            categoryName: reportingCategoryName ?? categoryName,
            categoryId: categoryId,
            price: price,
            images: nil,
            hasTax: false
        )
    }
    
    private func convertToSearchResult(_ candidate: CandidateItem, searchTerm: String, isNumeric: Bool) -> SearchResultItem {
        let matchType = isNumeric ? "barcode" : "fuzzy"
        let matchContext = isNumeric ? searchTerm : candidate.name // For barcode searches, use the searched barcode as context
        
        return SearchResultItem(
            id: candidate.id,
            name: candidate.name,
            sku: candidate.sku,
            price: candidate.price,
            barcode: candidate.barcode,
            categoryId: candidate.categoryId,
            categoryName: candidate.categoryName,
            variationName: nil,
            images: candidate.images,
            matchType: matchType,
            matchContext: matchContext,
            isFromCaseUpc: false,
            caseUpcData: nil,
            hasTax: candidate.hasTax
        )
    }
}

// MARK: - Supporting Types
// Note: CandidateItem and SearchResultWithScore are now defined in SwiftDataFuzzySearch.swift