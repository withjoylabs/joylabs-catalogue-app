import Foundation
import SwiftUI
import SQLite
import Combine
import os.log

/// SearchManager - Handles sophisticated search with optimized SQLite queries
/// Built specifically for iOS with industry-standard fuzzy search and tokenized ranking
class SearchManager: ObservableObject {
    // MARK: - Published Properties
    @Published var searchResults: [SearchResultItem] = []
    @Published var isSearching: Bool = false
    @Published var searchError: String?
    @Published var lastSearchTerm: String = ""
    @Published var currentSearchTerm: String? = nil
    @Published var hasMoreResults = false
    @Published var totalResultsCount: Int?
    @Published var isLoadingMore = false
    @Published var isDatabaseReady = false

    private var currentOffset = 0
    private let pageSize = 50

    // MARK: - Private Properties
    private let databaseManager: SQLiteSwiftCatalogManager
    private let imageURLManager: ImageURLManager
    private var searchTask: Task<Void, Never>?
    private let logger = Logger(subsystem: "com.joylabs.native", category: "SearchManager")
    
    // Fuzzy search engine for improved relevance scoring
    private let fuzzySearch = FuzzySearch()

    // Debouncing with intelligent delay
    private var searchSubject = PassthroughSubject<(String, SearchFilters), Never>()
    private var cancellables = Set<AnyCancellable>()
    
    // Query caching for improved performance
    private var searchCache: [String: (results: [SearchResultItem], timestamp: Date)] = [:]
    private let cacheExpirationTime: TimeInterval = 300 // 5 minutes
    
    // Fuzzy search result caching for pagination (stores ALL results from fuzzy search)
    private var fuzzySearchCache: [String: (allResults: [SearchResultItem], timestamp: Date)] = [:]
    private let fuzzyCacheExpirationTime: TimeInterval = 300 // 5 minutes
    

    // MARK: - Initialization
    init(databaseManager: SQLiteSwiftCatalogManager? = nil) {
        // Initialize database manager on main actor if needed
        if let manager = databaseManager {
            self.databaseManager = manager
            // Check if database is already connected
            if manager.getConnection() != nil {
                // Database already connected, mark as ready
                self.isDatabaseReady = true
                logger.debug("[Search] SearchManager using pre-connected shared database")
            }
        } else {
            // Create database manager asynchronously to avoid main actor issues
            self.databaseManager = SQLiteSwiftCatalogManager()
        }

        // Initialize image URL manager (can't use factory here due to MainActor isolation)
        self.imageURLManager = ImageURLManager(databaseManager: self.databaseManager)

        setupSearchDebouncing()

        // Initialize database connection asynchronously only if not already connected
        if !isDatabaseReady {
            Task.detached(priority: .background) {
                await self.initializeDatabaseConnection()
            }
        }
    }

    // MARK: - Database Initialization
    private func initializeDatabaseConnection() async {
        do {
            // Use existing connection or connect if not already connected
            if databaseManager.getConnection() == nil {
                try databaseManager.connect()
                logger.debug("[Search] Search manager connected to database")
            } else {
                logger.debug("[Search] Search manager using existing database connection")
            }

            // Tables are already created during app startup - no need to recreate
            logger.debug("[Search] Database tables already initialized during app startup")

            // Update on main thread without blocking
            Task { @MainActor in
                isDatabaseReady = true
            }
        } catch {
            logger.error("[Search] Search manager database connection failed: \(error)")
            // Update on main thread without blocking
            Task { @MainActor in
                searchError = "Database connection failed: \(error.localizedDescription)"
                isDatabaseReady = false
            }
        }
    }
    
    // MARK: - Public Methods
    
    
    func performSearch(searchTerm: String, filters: SearchFilters, loadMore: Bool = false) async -> [SearchResultItem] {
        // Port the exact logic from React Native performSearch with pagination
        let trimmedTerm = searchTerm.trimmingCharacters(in: .whitespacesAndNewlines)

        guard !trimmedTerm.isEmpty else {
            // Clear search state efficiently without blocking UI
            Task { @MainActor in
                if !searchResults.isEmpty {
                    searchResults = []
                }
                if !lastSearchTerm.isEmpty {
                    lastSearchTerm = ""
                }
                if currentOffset != 0 {
                    currentOffset = 0
                }
                if hasMoreResults {
                    hasMoreResults = false
                }
                if totalResultsCount != nil {
                    totalResultsCount = nil
                }
            }
            return []
        }

        // More aggressive minimum length - fuzzy search needs more context to be effective
        guard trimmedTerm.count >= 3 else {
            // Clear results for short queries but don't show error
            Task { @MainActor in
                if !searchResults.isEmpty {
                    searchResults = []
                }
                if hasMoreResults {
                    hasMoreResults = false
                }
                if totalResultsCount != nil {
                    totalResultsCount = nil
                }
            }
            return []
        }

        // Wait for database to be ready before performing search
        guard isDatabaseReady else {
            return []
        }

        // Reset pagination for new searches
        if !loadMore || lastSearchTerm != trimmedTerm {
            Task { @MainActor in
                currentOffset = 0
                searchResults = []
                totalResultsCount = nil
            }
        }

        Task { @MainActor in
            if loadMore {
                isLoadingMore = true
            } else {
                isSearching = true
            }
            searchError = nil
            lastSearchTerm = trimmedTerm
            currentSearchTerm = trimmedTerm
        }

        // Check cache first for non-paginated searches
        if currentOffset == 0 && !loadMore {
            let cacheKey = "\(trimmedTerm)_\(filters.name)_\(filters.sku)_\(filters.barcode)_\(filters.category)"
            if let cached = searchCache[cacheKey], Date().timeIntervalSince(cached.timestamp) < cacheExpirationTime {
                logger.debug("[Search] Returning cached results for: '\(trimmedTerm)'")
                Task { @MainActor in
                    searchResults = cached.results
                    totalResultsCount = cached.results.count
                    hasMoreResults = false
                    isSearching = false
                }
                return cached.results
            }
        }
        
        logger.info("[Search] Performing search for: '\(trimmedTerm)' (offset: \(self.currentOffset), loadMore: \(loadMore))")

        do {
            // Create cache key for fuzzy search results
            let fuzzySearchKey = "\(trimmedTerm)_\(filters.name)_\(filters.sku)_\(filters.barcode)_\(filters.category)"
            
            var allFuzzyResults: [SearchResultItem] = []
            
            // Check if we have cached fuzzy search results
            if let cached = fuzzySearchCache[fuzzySearchKey], 
               Date().timeIntervalSince(cached.timestamp) < fuzzyCacheExpirationTime {
                logger.debug("[Search] Using cached fuzzy search results for: '\(trimmedTerm)'")
                allFuzzyResults = cached.allResults
            } else {
                // Run fuzzy search once and cache ALL results
                logger.debug("[Search] Running fresh fuzzy search for: '\(trimmedTerm)'")
                let searchResult = try await searchLocalItems(
                    searchTerm: trimmedTerm,
                    filters: filters,
                    offset: 0,  // Always get all results for caching
                    limit: 1000 // Get ALL results
                )
                allFuzzyResults = searchResult.results
                
                // Cache the complete fuzzy search results
                fuzzySearchCache[fuzzySearchKey] = (allResults: allFuzzyResults, timestamp: Date())
                
                // Clean up old cache entries
                if fuzzySearchCache.count > 10 {
                    let sortedEntries = fuzzySearchCache.sorted { $0.value.timestamp > $1.value.timestamp }
                    let keepEntries = Array(sortedEntries.prefix(5))
                    fuzzySearchCache = Dictionary(uniqueKeysWithValues: keepEntries.map { ($0.key, $0.value) })
                }
            }
            
            // Apply pagination to cached results (this preserves fuzzy search ranking!)
            let localResults = Array(allFuzzyResults.dropFirst(currentOffset).prefix(pageSize))
            
            // Set total count from cached results (only for initial search)
            if currentOffset == 0 {
                Task { @MainActor in
                    totalResultsCount = allFuzzyResults.count
                }
            }


            // 3. Case UPC search (only for first page and if numeric)
            var caseUpcResults: [SearchResultItem] = []
            if currentOffset == 0 && trimmedTerm.allSatisfy(\.isNumber) && filters.barcode {
                caseUpcResults = try await searchCaseUpcItems(searchTerm: trimmedTerm)
                logger.debug("[Search] Case UPC search returned \(caseUpcResults.count) results")
            }
            

            // 4. Combine and deduplicate results
            let newResults = combineAndDeduplicateResults(
                localResults: localResults,
                caseUpcResults: caseUpcResults
            )
            

            // Check for mismatch between total count and actual results
            if currentOffset == 0 && self.totalResultsCount != nil && self.totalResultsCount! > 0 && newResults.isEmpty {
                logger.error("[Search] SEARCH MISMATCH: Total count shows \(self.totalResultsCount!) but combined results are empty for '\(trimmedTerm)'")
            }

            Task { @MainActor in
                if loadMore {
                    // Append new results, avoiding duplicates
                    let existingIds = Set(searchResults.map { $0.id })
                    let uniqueNewResults = newResults.filter { !existingIds.contains($0.id) }
                    searchResults.append(contentsOf: uniqueNewResults)
                    isLoadingMore = false
                    
                    // Update pagination state ONLY after successful load more
                    // (currentOffset was already incremented in loadMoreResults())
                    hasMoreResults = searchResults.count < (totalResultsCount ?? 0)
                } else {
                    searchResults = newResults
                    isSearching = false
                    
                    // For initial search, set up pagination state but don't increment offset yet
                    // Only increment when user actually requests more results
                    hasMoreResults = newResults.count < (totalResultsCount ?? 0)
                }

                // Images will be loaded on-demand when displayed in UI
            }

            // Cache results for future use (only cache initial searches, not pagination)
            if currentOffset == 0 && !loadMore && !newResults.isEmpty {
                let cacheKey = "\(trimmedTerm)_\(filters.name)_\(filters.sku)_\(filters.barcode)_\(filters.category)"
                searchCache[cacheKey] = (results: newResults, timestamp: Date())
                
                // Clean up old cache entries (keep only last 20 searches)
                if searchCache.count > 20 {
                    let sortedEntries = searchCache.sorted { $0.value.timestamp > $1.value.timestamp }
                    let keepEntries = Array(sortedEntries.prefix(15))
                    searchCache = Dictionary(uniqueKeysWithValues: keepEntries.map { ($0.key, $0.value) })
                }
            }
            
            let totalCount = newResults.count
            logger.info("[Search] Search completed: \(newResults.count) new results, \(totalCount) total")
            return newResults

        } catch {
            logger.error("[Search] Search failed: \(error)")

            Task { @MainActor in
                searchError = error.localizedDescription
                if loadMore {
                    isLoadingMore = false
                } else {
                    isSearching = false
                    searchResults = []
                }
            }

            return []
        }
    }
    
    func performSearchWithDebounce(searchTerm: String, filters: SearchFilters) {
        // Cancel any existing search asynchronously to avoid blocking main thread
        let taskToCancel = searchTask
        searchTask = nil

        // Cancel on background queue to avoid blocking
        Task.detached(priority: .background) {
            taskToCancel?.cancel()
        }

        // Send to debounced subject
        searchSubject.send((searchTerm, filters))
    }
    
    func loadMoreResults() {
        guard !isLoadingMore && hasMoreResults && !lastSearchTerm.isEmpty else { return }

        // Update offset BEFORE starting the load more search
        currentOffset += pageSize
        
        searchTask = Task.detached(priority: .userInitiated) { [weak self] in
            guard let self = self else { return }
            _ = await self.performSearch(
                searchTerm: self.lastSearchTerm,
                filters: SearchFilters(name: true, sku: true, barcode: true, category: false),
                loadMore: true
            )
        }
    }

    func clearSearch() {
        searchTask?.cancel()
        searchResults = []
        searchError = nil
        lastSearchTerm = ""
        currentSearchTerm = nil
        isSearching = false
        isLoadingMore = false
        hasMoreResults = false
        totalResultsCount = nil
        currentOffset = 0
        // Clear search cache and suggestions on explicit clear
        searchCache.removeAll()
        fuzzySearchCache.removeAll()
        suggestionsCache.removeAll()
        searchSuggestions = []
        isLoadingSuggestions = false
        logger.debug("[Search] Search cleared and caches purged")
        // Note: Don't reset isDatabaseReady as it's a persistent state
    }
    
    // MARK: - Private Methods
    private func setupSearchDebouncing() {
        // Smart debouncing optimized for fuzzy search
        searchSubject
            .debounce(for: .milliseconds(400), scheduler: DispatchQueue.global(qos: .userInitiated))
            .sink { [weak self] (searchTerm, filters) in
                guard let self = self else { return }
                
                let trimmedTerm = searchTerm.trimmingCharacters(in: .whitespacesAndNewlines)
                
                // Intelligent delay based on query complexity and length
                let delay: Int = {
                    if trimmedTerm.count < 3 { return 0 }         // Skip short queries immediately
                    if trimmedTerm.count == 3 { return 300 }      // Slower for short queries (more fuzzy work)
                    if trimmedTerm.count >= 4 && trimmedTerm.count <= 6 { return 200 } // Medium delay
                    if trimmedTerm.count > 6 { return 150 }       // Faster for longer queries (more precise)
                    return 250                                     // Default
                }()
                
                self.searchTask = Task.detached(priority: .userInitiated) { [weak self] in
                    if delay > 0 {
                        try? await Task.sleep(nanoseconds: UInt64(delay * 1_000_000))
                    }
                    guard let self = self, !Task.isCancelled else { return }
                    _ = await self.performSearch(searchTerm: searchTerm, filters: filters)
                }
            }
            .store(in: &cancellables)
    }
    
    private func searchLocalItems(searchTerm: String, filters: SearchFilters, offset: Int = 0, limit: Int = 50) async throws -> (results: [SearchResultItem], totalCount: Int) {
        // NEW: Use sophisticated FuzzySearch algorithm instead of broken LIKE queries
        guard let db = databaseManager.getConnection() else {
            throw SearchError.databaseError(SQLiteSwiftError.noConnection)
        }

        logger.debug("[Search] Using FuzzySearch algorithm for term: '\(searchTerm)'")
        
        // Use the sophisticated fuzzy search algorithm - get ALL results, don't truncate!
        let scoredResults = try fuzzySearch.performFuzzySearch(
            searchTerm: searchTerm,
            in: db,
            filters: filters,
            limit: 1000 // Get all results - don't let pagination truncate FuzzySearch ranking!
        )
        
        logger.info("[Search] FuzzySearch returned \(scoredResults.count) scored results")
        
        // Store total count BEFORE pagination
        let totalCount = scoredResults.count
        
        // Apply offset and limit to the scored results (pagination)
        let paginatedResults = Array(scoredResults.dropFirst(offset).prefix(limit))
        
        // Extract SearchResultItems from scored results
        let results = paginatedResults.map { $0.item }
        
        // Enrich with additional data that FuzzySearch doesn't include
        let enrichedResults = enrichSearchResults(results, db: db)
        
        logger.info("[Search] Returning \(enrichedResults.count) enriched results after pagination (\(totalCount) total)")
        return (results: enrichedResults, totalCount: totalCount)
    }


    // MARK: - Result Enrichment
    
    /// Enrich search results with additional data not provided by FuzzySearch
    private func enrichSearchResults(_ results: [SearchResultItem], db: Connection) -> [SearchResultItem] {
        return results.compactMap { result in
            // Get complete item data with enrichment
            return getCompleteItemData(itemId: result.id, db: db, matchType: result.matchType, matchContext: result.matchContext)
        }
    }

    func DELETED_generateSearchSuggestions(for partialQuery: String) async {
        let trimmedQuery = partialQuery.trimmingCharacters(in: .whitespacesAndNewlines)
        
        // Only generate suggestions for queries of 2+ characters
        guard trimmedQuery.count >= 2 && trimmedQuery.count <= 20 else {
            Task { @MainActor in
                searchSuggestions = []
                isLoadingSuggestions = false
            }
            return
        }
        
        // Check suggestions cache first
        let cacheKey = trimmedQuery.lowercased()
        if let cached = suggestionsCache[cacheKey], 
           Date().timeIntervalSince(cached.timestamp) < suggestionsCacheTime {
            Task { @MainActor in
                searchSuggestions = cached.suggestions
                isLoadingSuggestions = false
            }
            return
        }
        
        Task { @MainActor in
            isLoadingSuggestions = true
        }
        
        guard let db = databaseManager.getConnection() else {
            Task { @MainActor in
                searchSuggestions = []
                isLoadingSuggestions = false
            }
            return
        }
        
        var suggestions: [String] = []
        
        do {
            // Get name suggestions
            let nameQuery = """
                SELECT DISTINCT name FROM catalog_items 
                WHERE is_deleted = 0 AND LOWER(name) LIKE ? 
                ORDER BY name LIMIT 5
            """
            let nameStatement = try db.prepare(nameQuery)
            for row in try nameStatement.run(["%\(trimmedQuery.lowercased())%"]) {
                if let name = row[0] as? String {
                    suggestions.append(name)
                }
            }
            
            // Get category suggestions
            let categoryQuery = """
                SELECT DISTINCT category_name FROM catalog_items 
                WHERE is_deleted = 0 AND category_name IS NOT NULL 
                AND LOWER(category_name) LIKE ? 
                ORDER BY category_name LIMIT 3
            """
            let categoryStatement = try db.prepare(categoryQuery)
            for row in try categoryStatement.run(["%\(trimmedQuery.lowercased())%"]) {
                if let category = row[0] as? String, !suggestions.contains(category) {
                    suggestions.append(category)
                }
            }
            
            // Get SKU suggestions (if query looks like a SKU)
            if trimmedQuery.count >= 3 && (trimmedQuery.contains("-") || trimmedQuery.allSatisfy({ $0.isNumber || $0.isLetter })) {
                let skuQuery = """
                    SELECT DISTINCT iv.sku FROM item_variations iv
                    JOIN catalog_items ci ON iv.item_id = ci.id
                    WHERE iv.is_deleted = 0 AND ci.is_deleted = 0 
                    AND LOWER(iv.sku) LIKE ? 
                    ORDER BY iv.sku LIMIT 3
                """
                let skuStatement = try db.prepare(skuQuery)
                for row in try skuStatement.run(["%\(trimmedQuery.lowercased())%"]) {
                    if let sku = row[0] as? String, !suggestions.contains(sku) {
                        suggestions.append(sku)
                    }
                }
            }
            
        } catch {
            logger.error("[Search] Failed to generate suggestions: \(error)")
        }
        
        // Cache the suggestions
        suggestionsCache[cacheKey] = (suggestions: suggestions, timestamp: Date())
        
        // Clean up old cache entries
        if suggestionsCache.count > 50 {
            let sortedEntries = suggestionsCache.sorted { $0.value.timestamp > $1.value.timestamp }
            let keepEntries = Array(sortedEntries.prefix(30))
            suggestionsCache = Dictionary(uniqueKeysWithValues: keepEntries.map { ($0.key, $0.value) })
        }
        
        Task { @MainActor in
            searchSuggestions = suggestions
            isLoadingSuggestions = false
        }
        
        logger.debug("[Search] Generated \(suggestions.count) suggestions for '\(trimmedQuery)'")
    }
    
    func getPopularSearchTerms() async -> [String] {
        guard let db = databaseManager.getConnection() else {
            return []
        }
        
        var popularTerms: [String] = []
        
        do {
            // Get popular categories
            let categoryQuery = """
                SELECT category_name, COUNT(*) as item_count 
                FROM catalog_items 
                WHERE is_deleted = 0 AND category_name IS NOT NULL 
                GROUP BY category_name 
                ORDER BY item_count DESC 
                LIMIT 8
            """
            let categoryStatement = try db.prepare(categoryQuery)
            for row in try categoryStatement.run([]) {
                if let category = row[0] as? String {
                    popularTerms.append(category)
                }
            }
            
            // Get some common product words from item names
            let commonWordsQuery = """
                SELECT name FROM catalog_items 
                WHERE is_deleted = 0 AND name IS NOT NULL 
                ORDER BY RANDOM() 
                LIMIT 20
            """
            let wordsStatement = try db.prepare(commonWordsQuery)
            var wordCounts: [String: Int] = [:]
            
            for row in try wordsStatement.run([]) {
                if let name = row[0] as? String {
                    let words = name.lowercased()
                        .components(separatedBy: .whitespacesAndNewlines)
                        .filter { $0.count >= 4 && $0.count <= 12 } // Reasonable word length
                    
                    for word in words {
                        wordCounts[word, default: 0] += 1
                    }
                }
            }
            
            // Add top common words
            let sortedWords = wordCounts.sorted { $0.value > $1.value }
            for (word, _) in sortedWords.prefix(4) {
                if !popularTerms.contains(word) {
                    popularTerms.append(word.capitalized)
                }
            }
            
        } catch {
            logger.error("[Search] Failed to get popular terms: \(error)")
        }
        
        return popularTerms
    }
    
    // MARK: - Result Enrichment
    
    /// Enrich search results with additional data not provided by FuzzySearch
    private func enrichSearchResults(_ results: [SearchResultItem], db: Connection) -> [SearchResultItem] {
        return results.compactMap { result in
            // Get complete item data with enrichment
            return getCompleteItemData(itemId: result.id, db: db, matchType: result.matchType, matchContext: result.matchContext)
        }
    }
    




    // MARK: - Unified Item Retrieval

    /// Single source of truth for retrieving complete item data by item ID
    /// This function is used by ALL search types to ensure consistency
    private func getCompleteItemData(itemId: String, db: Connection, matchType: String, matchContext: String? = nil) -> SearchResultItem? {
        do {
            // Simple query to get basic item data and first variation
            let items = CatalogTableDefinitions.catalogItems.alias("ci")
            let variations = CatalogTableDefinitions.itemVariations.alias("iv")

            let query = items
                .select(
                    // Item data
                    items[CatalogTableDefinitions.itemId],
                    items[CatalogTableDefinitions.itemName],
                    items[CatalogTableDefinitions.itemCategoryId],
                    items[CatalogTableDefinitions.itemReportingCategoryId],
                    items[CatalogTableDefinitions.itemReportingCategoryName],
                    items[CatalogTableDefinitions.itemCategoryName],
                    // First variation data (for SKU, price, UPC, name)
                    variations[CatalogTableDefinitions.variationSku],
                    variations[CatalogTableDefinitions.variationUpc],
                    variations[CatalogTableDefinitions.variationPriceAmount],
                    variations[CatalogTableDefinitions.variationName]
                )
                .join(.leftOuter, variations, on: items[CatalogTableDefinitions.itemId] == variations[CatalogTableDefinitions.variationItemId] && variations[CatalogTableDefinitions.variationIsDeleted] == false)
                .filter(items[CatalogTableDefinitions.itemId] == itemId && items[CatalogTableDefinitions.itemIsDeleted] == false)
                .limit(1) // We only need one result per item

            guard let row = try db.pluck(query) else {
                return nil
            }

            // Extract all data from the unified query
            let itemName = try row.get(items[CatalogTableDefinitions.itemName])
            let categoryId = try? row.get(items[CatalogTableDefinitions.itemReportingCategoryId])
            let reportingCategoryName = try? row.get(items[CatalogTableDefinitions.itemReportingCategoryName])
            let regularCategoryName = try? row.get(items[CatalogTableDefinitions.itemCategoryName])
            let categoryName = reportingCategoryName ?? regularCategoryName

            let sku = try? row.get(variations[CatalogTableDefinitions.variationSku])
            let upc = try? row.get(variations[CatalogTableDefinitions.variationUpc])
            let priceAmount = try? row.get(variations[CatalogTableDefinitions.variationPriceAmount])
            let variationName = try? row.get(variations[CatalogTableDefinitions.variationName])

            // Get case UPC data separately if needed (for case UPC match type)
            var caseUpc: String? = nil
            var caseCost: Double? = nil

            if matchType == "case_upc" {
                // Only query team data when we actually need it
                let teamData = CatalogTableDefinitions.teamData.alias("td")
                let teamQuery = teamData
                    .select(
                        teamData[CatalogTableDefinitions.teamCaseUpc],
                        teamData[CatalogTableDefinitions.teamCaseCost]
                    )
                    .filter(teamData[CatalogTableDefinitions.teamDataItemId] == itemId)
                    .limit(1)

                if let teamRow = try db.pluck(teamQuery) {
                    caseUpc = try? teamRow.get(teamData[CatalogTableDefinitions.teamCaseUpc])
                    caseCost = try? teamRow.get(teamData[CatalogTableDefinitions.teamCaseCost])
                }
            }

            // Determine price and barcode based on match type
            let price: Double?
            let barcode: String?
            let isFromCaseUpc: Bool

            switch matchType {
            case "case_upc":
                price = caseCost // Case cost is already in dollars
                barcode = caseUpc
                isFromCaseUpc = true
            default:
                // Convert price from cents to dollars for regular items
                if let amount = priceAmount, amount > 0 {
                    let convertedPrice = Double(amount) / 100.0
                    price = convertedPrice.isFinite && !convertedPrice.isNaN && convertedPrice > 0 ? convertedPrice : nil
                } else {
                    price = nil
                }
                barcode = upc
                isFromCaseUpc = false
            }

            // Tax checking removed - not needed for search results
            let hasTax = false

            // Get primary image URL using unified approach
            let images = getPrimaryImageForSearchResult(itemId: itemId)

            return SearchResultItem(
                id: itemId,
                name: itemName,
                sku: sku,
                price: price,
                barcode: barcode,
                categoryId: categoryId,
                categoryName: categoryName,
                variationName: variationName,
                images: images,
                matchType: matchType,
                matchContext: matchContext,
                isFromCaseUpc: isFromCaseUpc,
                caseUpcData: isFromCaseUpc ? CaseUpcData(
                    caseUpc: caseUpc ?? "",
                    caseCost: caseCost ?? 0.0,
                    caseQuantity: 1, // Default, could be enhanced
                    vendor: nil,
                    discontinued: false,
                    notes: nil
                ) : nil,
                hasTax: hasTax
            )

        } catch {
            logger.error("Failed to retrieve item data for \(itemId): \(error)")
            return nil
        }
    }

    // MARK: - Unified Image Integration

    /// Get primary image for search result using CORRECT database order
    private func getPrimaryImageForSearchResult(itemId: String) -> [CatalogImage]? {
        do {
            guard let db = databaseManager.getConnection() else {
                return nil
            }
            
            // Get item's image_ids array from database (CORRECT approach)
            let selectQuery = """
                SELECT data_json FROM catalog_items
                WHERE id = ? AND is_deleted = 0
            """
            
            let statement = try db.prepare(selectQuery)
            for row in try statement.run([itemId]) {
                let dataJsonString = row[0] as? String ?? "{}"
                let dataJsonData = dataJsonString.data(using: String.Encoding.utf8) ?? Data()
                
                if let currentData = try JSONSerialization.jsonObject(with: dataJsonData) as? [String: Any] {
                    var imageIds: [String]? = nil
                    
                    // Try nested under item_data first (current format)
                    if let itemData = currentData["item_data"] as? [String: Any] {
                        imageIds = itemData["image_ids"] as? [String]
                    }
                    
                    // Fallback to root level (legacy format)
                    if imageIds == nil {
                        imageIds = currentData["image_ids"] as? [String]
                    }
                    
                    if let imageIdArray = imageIds, let primaryImageId = imageIdArray.first {
                    // Get image mapping for this specific image ID
                    let imageMappings = try imageURLManager.getImageMappings(for: itemId, objectType: "ITEM")
                    if let mapping = imageMappings.first(where: { $0.squareImageId == primaryImageId }) {
                        let catalogImage = CatalogImage(
                            id: primaryImageId,
                            type: "IMAGE",
                            updatedAt: ISO8601DateFormatter().string(from: mapping.lastAccessedAt),
                            version: nil,
                            isDeleted: false,
                            presentAtAllLocations: true,
                            imageData: ImageData(
                                name: nil,
                                url: mapping.originalAwsUrl,
                                caption: nil,
                                photoStudioOrderId: nil
                            )
                        )

                        return [catalogImage]
                        }
                    }
                }
            }
            
        } catch {
            // Silent failure for image retrieval - don't spam logs
        }
        
        return nil
    }



    private func removeDuplicatesAndRank(results: [SearchResultItem], searchTerm: String) -> [SearchResultItem] {
        // Remove duplicates by ID
        var uniqueResults: [String: SearchResultItem] = [:]

        for result in results {
            // Just keep the first occurrence since FuzzySearch already handles ranking
            if uniqueResults[result.id] == nil {
                uniqueResults[result.id] = result
            }
        }

        // Preserve FuzzySearch ranking - don't re-sort alphabetically!
        // Return results in the same order they were provided (FuzzySearch already sorted them)
        return results.compactMap { result in
            uniqueResults[result.id]
        }
    }



    private func searchCaseUpcItems(searchTerm: String) async throws -> [SearchResultItem] {
        guard let db = databaseManager.getConnection() else {
            throw SearchError.databaseError(SQLiteSwiftError.noConnection)
        }

        logger.debug("ðŸ” Searching Case UPC for numeric term: \(searchTerm)")

        // Check if team_data table has any case UPC data
        let teamDataCount = try db.scalar(
            CatalogTableDefinitions.teamData
                .filter(CatalogTableDefinitions.teamCaseUpc != nil)
                .count
        )

        if teamDataCount == 0 {
            logger.info("ðŸ“¦ No team data with case UPC found - table empty or user not signed in")
            return []
        }

        let items = CatalogTableDefinitions.catalogItems.alias("ci")
        let teamData = CatalogTableDefinitions.teamData.alias("td")

        let query = items
            .select(
                items[CatalogTableDefinitions.itemId],
                teamData[CatalogTableDefinitions.teamCaseUpc]
            )
            .join(teamData, on: items[CatalogTableDefinitions.itemId] == teamData[CatalogTableDefinitions.teamDataItemId])
            .filter(teamData[CatalogTableDefinitions.teamCaseUpc] == searchTerm &&
                   items[CatalogTableDefinitions.itemIsDeleted] == false &&
                   teamData[CatalogTableDefinitions.teamCaseUpc] != nil)
            .order(items[CatalogTableDefinitions.itemName].asc)
            .limit(50)

        return try db.prepare(query).compactMap { row in
            do {
                let itemId = try row.get(items[CatalogTableDefinitions.itemId])
                let caseUpc = try row.get(teamData[CatalogTableDefinitions.teamCaseUpc])

                // Use unified retrieval for complete item data
                return getCompleteItemData(itemId: itemId, db: db, matchType: "case_upc", matchContext: caseUpc)
            } catch {
                logger.error("Failed to create case UPC search result: \(error)")
                return nil
            }
        }
    }
    
    private func combineAndDeduplicateResults(
        localResults: [SearchResultItem],
        caseUpcResults: [SearchResultItem]
    ) -> [SearchResultItem] {
        // Combine all results and use the advanced ranking system
        let allResults = localResults + caseUpcResults

        // The removeDuplicatesAndRank method already handles deduplication and ranking
        return removeDuplicatesAndRank(results: allResults, searchTerm: lastSearchTerm)
    }



}

// MARK: - Supporting Types

enum SearchError: LocalizedError {
    case databaseError(Error)
    case invalidSearchTerm
    case noConnection

    var errorDescription: String? {
        switch self {
        case .databaseError(let error):
            return "Database search error: \(error.localizedDescription)"
        case .invalidSearchTerm:
            return "Invalid search term"
        case .noConnection:
            return "Database connection not available"
        }
    }


}

